#pragma kernel VertexRecompute
#pragma kernel GenTextures




[numthreads(8, 1, 1)]
void VertexRecompute(uint id : SV_DISPATCHTHREADID)
{
    if (id < _vNum)
    {
        // Position actuelle du vertex
        float3 vPos = normalize(_vertices[id]);

        const float Noffset = 0.002;
        
        float3 posXPlus = normalize(vPos + float3(Noffset, 0.0, 0.0));
        float3 posXMinus = normalize(vPos - float3(Noffset, 0.0, 0.0));
        float3 posYPlus = normalize(vPos + float3(0.0, Noffset, 0.0));
        float3 posYMinus = normalize(vPos - float3(0.0, Noffset, 0.0));
        float3 posZPlus = normalize(vPos + float3(0.0, 0.0, Noffset));

        float4 bChan = getBiomeChannels(vPos, _scale, 0.75, _offset);
        float4 bChanXP = getBiomeChannels(posXPlus, _scale, 0.75, _offset);
        float4 bChanXM = getBiomeChannels(posXMinus, _scale, 0.75, _offset);
        float4 bChanYP = getBiomeChannels(posYPlus, _scale, 0.75, _offset);
        float4 bChanYM = getBiomeChannels(posYMinus, _scale, 0.75, _offset);
        float4 bChanZP = getBiomeChannels(posZPlus, _scale, 0.75, _offset);
        float4 bChanZM = getBiomeChannels(posZMinus, _scale, 0.75, _offset);

        float4 res;
        float4 resXP;
        float4 resXM;
        float4 resYP;
        float4 resYM;
        float4 resZP;
        float4 resZM;


        // get only the predicates matching => send them to sampleHeight as additional params => final position is the lerped sum of biome layers.
        for (int i = 0; i < _numBiomes; i++)
        {
            float4 mP = float4(_minPredicates[i][0], _minPredicates[i][1], _minPredicates[i][2], _minPredicates[i][3]);
            float4 MP = float4(_maxPredicates[i][0], _maxPredicates[i][1], _maxPredicates[i][2], _maxPredicates[i][3]);
            res = processBiomes(vPos, bChan, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], res, _biomeDebugColor[i]);
            resXP = processBiomes(posXPlus, bChanXP, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], resXP, _biomeDebugColor[i]);
            resXM = processBiomes(posXMinus, bChanXM, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], resXM, _biomeDebugColor[i]);
            resYP = processBiomes(posYPlus, bChanYP, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], resYP, _biomeDebugColor[i]);
            resYM = processBiomes(posYMinus, bChanYM, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], resYM, _biomeDebugColor[i]);
            resZP = processBiomes(posZPlus, bChanZP, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], resZP, _biomeDebugColor[i]);
            resZM = processBiomes(posZMinus, bChanZM, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], resZM, _biomeDebugColor[i]);
        }

        res += bChan.x * _multiplier;
        resXP += bChanXP.x * _multiplier;
        resXM += bChanXM.x * _multiplier;
        resYP += bChanYP.x * _multiplier;
        resYM += bChanYM.x * _multiplier;
        resZP += bChanZP.x * _multiplier;
        resZM += bChanZM.x * _multiplier;

        // Position finale du vertex après déformation
        float3 vFinalPos = vPos * (1.0 + res.x) * _bRad;
        _vertices[id] = vFinalPos;


        // Calcul des positions déformées dans les trois directions
        posXPlus = posXPlus * (1.0 + resXP.x) * _bRad;

        posXMinus = posXMinus * (1.0 + resXM.x) * _bRad;

        posYPlus = posYPlus * (1.0 + resYP.x) * _bRad;

        posYMinus = posYMinus * (1.0 + resYM.x) * _bRad;

        posZPlus = posZPlus * (1.0 + resZP.x) * _bRad;

        posZMinus = posZMinus * (1.0 + resZM.x) * _bRad;

        // Calcul des gradients dans chaque direction
        float3 tangentX = posXPlus - posXMinus;
        float3 tangentY = posYPlus - posYMinus;
        float3 tangentZ = posZPlus - posZMinus;

        // X => YZ||ZY
        // Y => XZ||ZX
        // Z => XY||YX
        float3 normal;
        if (abs(vPos.x) >= abs(vPos.y) && abs(vPos.x) >= abs(vPos.z))
        {
            if (vPos.x >= 0.0) normal = cross(tangentY, tangentZ);
            else normal = cross(tangentZ, tangentY);
        }
        else if (abs(vPos.y) >= abs(vPos.x) && abs(vPos.y) >= abs(vPos.z))
        {
            if (vPos.y >= 0.0) normal = cross(tangentZ, tangentX);
            else normal = cross(tangentX, tangentZ);
        }
        else
        {
            if (vPos.z >= 0.0) normal = cross(tangentX, tangentY);
            else normal = cross(tangentY, tangentX);
        }

        // Normalisation finale
        _normals[id] = normalize(normal);
        _color[id] = float4(res.gba, 1.);
    }
}

// FOR FRAGMENT
[numthreads(8, 8, 1)]
void GenTextures(uint2 id : SV_DispatchThreadID)
{
    float3 dX = (_mx - _origin) / 256;
    float3 dY = (_my - _origin) / 256;
    int bToUse = -1;
    float3 vPos = normalize(_origin + (dX * id.x) + (dY * id.y));
    float4 bChann = getBiomeChannels(vPos, _scale, 0.75, _offset);
    float3 col;
    float blend;
    //TODO integrate tolerance here! and put color computation also here
    for (int i = 0; i < _numBiomes; i++)
    {
        float4 mP = float4(_minPredicates[i][0], _minPredicates[i][1], _minPredicates[i][2], _minPredicates[i][3]);
        float4 MP = float4(_maxPredicates[i][0], _maxPredicates[i][1], _maxPredicates[i][2], _maxPredicates[i][3]);
        int b = getBiome(vPos, bChann, mP, MP, i, _blendingFactor[i]);
        if (b!=-1)
        {
            if (bToUse != -1)
            {
                float tint = simpleNoise(vPos, _bTexScale[i], 1, lvl+1, _bTexOffset[i]);
                float3 nCol = lerp(_bPCol[i], _bSCol[i], tint * 0.5 + 0.5);
                col = lerp(col, nCol, blend);
            }
            else
            {
                blend = eucDist(vPos, bChann, MP, _blendingFactor[i]);
                float tint = simpleNoise(vPos, _bTexScale[i], 1, lvl+1, _bTexOffset[i]);
                col = lerp(_bPCol[i], _bSCol[i], tint * 0.5 + 0.5);
            }
            bToUse = b;
        }
    }
    bToUse = bToUse == -1? 0 : bToUse;
    _albedo[id.xy] = float4(col, 1.);

    //TODO rework to use simplex noise based texture, with lod = layer !
    // also add a blending, the factor being distance between matching preds normalized => used to lerp between sources.
    // for the detail map, use a predictable generator that choose different tilable tex depending on the position. (Should include bigger tex than one tile?).
}
