

//#pragma kernel GenTextures

#include "../Libs/FractalNoise.cginc"

#pragma kernel VertexRecompute
#pragma kernel ExecuteBuildPass
#pragma kernel GenTextures



// Mesh buffer
// Used for deformation
RWStructuredBuffer<float3> _vertices;
RWStructuredBuffer<float3> _normals;
RWStructuredBuffer<float4> _color;




StructuredBuffer<float4> _minPredicates;
StructuredBuffer<float4> _maxPredicates;
uint _vNum; // avoid out of bound
uint _numBiomes;

float _scale; //Biome scale
float3 _offset; //Biome offset
float _bRad; // Base planet radius

StructuredBuffer<float> _blendingFactor;
StructuredBuffer<float> _BiomeScale;
StructuredBuffer<float> _BiomeMul;
StructuredBuffer<float> _BiomeNL;
StructuredBuffer<float3> _BiomeOffset;
StructuredBuffer<float> _BiomePersistence;
StructuredBuffer<float> _BiomeLacunarity;
StructuredBuffer<float> _BiomeVShift;
StructuredBuffer<float3> _BiomeCol;



float3 _origin; // origin vertex
float3 _mx; // max U vertex
float3 _my; // max V vertex






















float simpleNoise(float3 pos, float scale, float multiplier, int numLayers, float3 offset, float persistence, float lacunarity, float verticalShift)
{
    float4 params[3];
    params[0] = float4(offset, numLayers);
    params[1] = float4(persistence, lacunarity, scale, multiplier);
    params[2] = float4(verticalShift, 0, 0, 0);
    return simpleNoise(pos, params);
}

// helper for simplexNoise generator
float simpleNoise(float3 pos, float scale, float multiplier, float3 offset)
{
    float4 params[3];
    params[0] = float4(offset, 1);
    params[1] = float4(.5, 2, scale, multiplier);
    params[2] = float4(0, 0, 0, 0);
    return simpleNoise(pos, params);
}

float4 getBiomeChannels(float3 pos, float scale, float multiplier, float3 offset)
{
    //NOTE 4 dim noise map
    return float4(
        clamp(simpleNoise(pos + offset, scale, multiplier), -1, 1),
        clamp(simpleNoise(pos + offset + float3(2, 0, 0), scale, multiplier), -1, 1),
        clamp(simpleNoise(pos + offset + float3(0, 0, 2), scale, multiplier), -1, 1),
        dot(pos, float3(0, 1, 0))
    );
}

int getBiome(float3 sPoint, float4 chann, float4 minp, float4 maxp, int id, float tol)
{
    if (minp.x <= chann.x && minp.y <= chann.y && minp.z <= chann.z && minp.w <= chann.w && maxp.x + tol >= chann.x && maxp.y + tol >= chann.y && maxp.z + tol >= chann.z && maxp.w + tol >= chann.w) return id;
    return -1;
}

float eucDist(float3 sPoint, float4 chann, float4 maxp, float tol)
{
    //is offshot? no => -1
    int numMatch = (chann.x > maxp.x ? 1 : 0) + (chann.y > maxp.y ? 1 : 0) + (chann.z > maxp.z ? 1 : 0) + (chann.w > maxp.w ? 1 : 0);
    
    return numMatch == 0? 0 : ((chann.x > maxp.x ? (chann.x - maxp.x) / tol : 0) + (chann.y > maxp.y ? (chann.y - maxp.y) / tol : 0) + (chann.z > maxp.z ? (chann.z - maxp.z) / tol : 0) + (chann.w > maxp.w ? (chann.w - maxp.w) / tol : 0)) / numMatch;
}

float4 sampleHeight(float3 pos, float scale, float3 offset)
{
    float3 n = normalize(pos);
    float4 bChan = getBiomeChannels(n, scale, 0.75, offset);
    float4 res;
    int exactBiome=-1;
    float blend;
    for (uint i = 0; i < _numBiomes; i++)
    {
        float4 mP = float4(_minPredicates[i][0], _minPredicates[i][1], _minPredicates[i][2], _minPredicates[i][3]);
        float4 MP = float4(_maxPredicates[i][0], _maxPredicates[i][1], _maxPredicates[i][2], _maxPredicates[i][3]);
        if ((mP.x <= bChan.x && bChan.x <= MP.x) && (mP.y <= bChan.y && bChan.y <= MP.y) && ((mP.z <= bChan.z && bChan.z <= MP.z)) && (mP.w <= bChan.w && bChan.w <= MP.w))
        {
            exactBiome = i;
            res = simpleNoise(n, _BiomeScale[i], _BiomeMul[i], _BiomeNL[i], _BiomeOffset[i], _BiomePersistence[i], _BiomeLacunarity[i], _BiomeVShift[i]);
            break;
        }
    }
    int matchCount = 0;
    float4 buff;
    float blendM;
    for (uint j = 0; j < _numBiomes; j++)
    {
        float4 mP = float4(_minPredicates[j][0], _minPredicates[j][1], _minPredicates[j][2], _minPredicates[j][3]);
        float4 MP = float4(_maxPredicates[j][0], _maxPredicates[j][1], _maxPredicates[j][2], _maxPredicates[j][3]);
        int b = getBiome(n, bChan, mP, MP, j, _blendingFactor[j]);
        if (b!=-1 && b != exactBiome)
        {
            blend = eucDist(n, bChan, MP, _blendingFactor[j]);
            blendM += blend;
            float nRes = simpleNoise(n, _BiomeScale[j], _BiomeMul[j], _BiomeNL[j], _BiomeOffset[j], _BiomePersistence[j], _BiomeLacunarity[j], _BiomeVShift[j]);
            buff.x += lerp(res.x, nRes, blend);
            buff.yzw += lerp(res.gba, _BiomeCol[j], blend);
            matchCount++;
        }
    }
    //TODO check me!
    if (matchCount > 0)
    {
        res = buff / matchCount;
    }
    return res;
}

[numthreads(8, 1, 1)]
void VertexRecompute(uint id : SV_DISPATCHTHREADID)
{
    if (id < _vNum)
    {
        // Position actuelle du vertex
        float3 vPos = normalize(_vertices[id]);

        const float Noffset = 0.002;
        
        
        float3 posXPlus = normalize(vPos + float3(Noffset, 0.0, 0.0));
        float3 posXMinus = normalize(vPos - float3(Noffset, 0.0, 0.0));
        float3 posYPlus = normalize(vPos + float3(0.0, Noffset, 0.0));
        float3 posYMinus = normalize(vPos - float3(0.0, Noffset, 0.0));
        float3 posZPlus = normalize(vPos + float3(0.0, 0.0, Noffset));
        float3 posZMinus = normalize(vPos - float3(0.0, 0.0, Noffset));

        float4 res = sampleHeight(vPos, _scale, _offset);
        float4 resXP = sampleHeight(posXPlus, _scale, _offset);
        float4 resXM = sampleHeight(posXMinus, _scale, _offset);
        float4 resYP = sampleHeight(posYPlus, _scale, _offset);
        float4 resYM = sampleHeight(posYMinus, _scale, _offset);
        float4 resZP = sampleHeight(posZPlus, _scale, _offset);
        float4 resZM = sampleHeight(posZMinus, _scale, _offset);
        // Position finale du vertex après déformation
        float3 vFinalPos = vPos * (1.0 + res.x) * _bRad;
        _vertices[id] = vFinalPos;


        // Calcul des positions déformées dans les trois directions
        posXPlus = posXPlus * (1.0 + resXP.x) * _bRad;
        posXMinus = posXMinus * (1.0 + resXM.x) * _bRad;
        posYPlus = posYPlus * (1.0 + resYP.x) * _bRad;
        posYMinus = posYMinus * (1.0 + resYM.x) * _bRad;
        posZPlus = posZPlus * (1.0 + resZP.x) * _bRad;
        posZMinus = posZMinus * (1.0 + resZM.x) * _bRad;

        // Calcul des gradients dans chaque direction
        float3 tangentX = posXPlus - posXMinus;
        float3 tangentY = posYPlus - posYMinus;
        float3 tangentZ = posZPlus - posZMinus;

        // X => YZ||ZY
        // Y => XZ||ZX
        // Z => XY||YX
        float3 normal;
        if (abs(vPos.x) >= abs(vPos.y) && abs(vPos.x) >= abs(vPos.z))
        {
            if (vPos.x >= 0.0) normal = cross(tangentY, tangentZ);
            else normal = cross(tangentZ, tangentY);
        }
        else if (abs(vPos.y) >= abs(vPos.x) && abs(vPos.y) >= abs(vPos.z))
        {
            if (vPos.y >= 0.0) normal = cross(tangentZ, tangentX);
            else normal = cross(tangentX, tangentZ);
        }
        else
        {
            if (vPos.z >= 0.0) normal = cross(tangentX, tangentY);
            else normal = cross(tangentY, tangentX);
        }

        // Normalisation finale
        _normals[id] = normalize(normal);
        _color[id] = float4(res.gba, 1.);
    }
}

RWTexture3D<float4> _tex;



uint _biomeID;
int _passType;
float4 _col; // 0
float4 _sCol;
float _Scale;
float _Multiplier;
float _Lacunarity;
float _Persistence;
float3 _Offset;
float _VerticalShift;
int _NumLayers;



void FillPass(RWTexture3D<float4> outTex, float4 col, int3 uv)
{
    outTex[uv] = col;
}

void NoisePass(RWTexture3D<float4> outTex, int3 uv, float3 pos, float scale, float mul, float lac, float per, int nl, float3 off, float vs, float4 col, float4 scol)
{
    outTex[uv] = lerp(col, scol, simpleNoise(normalize(pos), scale, mul, nl, off, per, lac, vs));
}

[numthreads(8, 8, 1)]
void ExecuteBuildPass(uint2 id : SV_DISPATCHTHREADID)
{
    switch (_passType)
    {
        case 0:
            FillPass(_tex, _col, int3(id, _biomeID));
            break;
        case 1:
            float3 dX = (_mx - _origin) / 256;
            float3 dY = (_my - _origin) / 256;
            float3 pos = normalize(_origin + (dX * id.x) + (dY * id.y));
            NoisePass(_tex, int3(id, _biomeID), pos, _Scale, _Multiplier, _Lacunarity, _Persistence, _NumLayers, _Offset, _VerticalShift, _col, _sCol);
            break;
    }
}



Texture3D<float4> _source;
RWTexture2D<float4> _dest;

[numthreads(8, 8, 1)]
void GenTextures(uint2 id : SV_DispatchThreadID)
{
    float3 dX = (_mx - _origin) / 256;
    float3 dY = (_my - _origin) / 256;
    int bToUse = -1;
    float3 vPos = normalize(_origin + (dX * (id.x)) + (dY * (id.y)));
    float4 bChann = getBiomeChannels(vPos, _scale, 0.75, _offset);
    float3 col;
    float blend;
    //TODO integrate tolerance here! and put color computation also here
    for (uint i = 0; i < _numBiomes; i++)
    {
        float4 mP = float4(_minPredicates[i][0], _minPredicates[i][1], _minPredicates[i][2], _minPredicates[i][3]);
        float4 MP = float4(_maxPredicates[i][0], _maxPredicates[i][1], _maxPredicates[i][2], _maxPredicates[i][3]);
        int b = getBiome(vPos, bChann, mP, MP, i, _blendingFactor[i]);
        if (b != -1)
        {
            if (bToUse != -1)
            {
                float3 nCol = _source[int3(id.xy, i)].rgb;
                col = lerp(col, nCol, blend);
            }
            else
            {
                blend = eucDist(vPos, bChann, MP, _blendingFactor[i]);
                col = _source[int3(id.xy, i)].rgb;
            }
            bToUse = b;
        }
    }
    bToUse = bToUse == -1 ? 0 : bToUse;
    _dest[id.xy] = float4(col, 1.);
}
