#pragma kernel NHMapGen
#pragma kernel VertexRecompute

#include "../Libs/FractalNoise.cginc"



//kernel 0
RWTexture2D<float4> _NHMap;
//kernel 1, per vertex
RWStructuredBuffer<float3> _vertices;
RWStructuredBuffer<float3> _normals;
//encode biome map for debug
RWStructuredBuffer<float4> _color;


//all ker
uint _vNum;
float _bRad;
//NOTE un-normalized chunk bounds
float3 _origin;
float3 _mx;
float3 _my;

//Biome driver
float _scale;
float _multiplier;
float3 _offset;


// Per biomes
int _numBiomes;
StructuredBuffer<float4> _minPredicates;
StructuredBuffer<float4> _maxPredicates;
StructuredBuffer<uint> _genToUse;
StructuredBuffer<float4x4> _paramsOfGen;
StructuredBuffer<float> _blendingFactor;






// helper for simplexNoise generator
float simpleNoise(float3 pos, float scale, float multiplier, float3 offset)
{
    float4 params[3];
    params[0] = float4(offset, 1);
    params[1] = float4(.5, 2, scale, multiplier);
    params[2] = float4(0, 0, 0, 0);
    return simpleNoise(pos, params);
}



float4 getBiomeChannels(float3 pos, float scale, float multiplier, float3 offset)
{
    //TODO 4 dim noise map
    return float4(
        clamp(simpleNoise(pos + offset, scale, multiplier), -1, 1),
        clamp(simpleNoise(pos + offset + float3(2, 0, 0), scale, multiplier), -1, 1),
        clamp(simpleNoise(pos + offset + float3(0, 0, 2), scale, multiplier), -1, 1),
        dot(pos, float3(0, 1, 0))
    );
}

// TODO Replace matching then smoothing of the biomes to return the final height
float sampleHeight(float3 sPoint, int id, float4x4 params)
{
    if (id == 1)
    {
        float4 args0 = params._m00_m10_m20_m30;
        float4 args1 = params._m01_m11_m21_m31;
        return simpleNoise(sPoint, args0.x, args0.y);
    }
    else return 0.0;
}
float smoothMax(float d1, float d2, float k)
{
	float h = clamp(0.5 - 0.5 * (d2 + d1)/k, 0.0, 1.0);
	return lerp(d2, -d1, h) + k*h*(1.0 - h);
}

float processBiomes(float3 sPoint, float4 chann, float4 minp, float4 maxp, uint genToUse, float4x4 params, float lf, float ph)
{
    float h = 0.0;
    if (minp.x <= chann.x && minp.y <= chann.y && minp.z <= chann.z && minp.w <= chann.w && maxp.x > chann.x && maxp.y > chann.y && maxp.z > chann.z && maxp.w > chann.w) h = sampleHeight(sPoint, genToUse, params);
    return h!=0.0? ph != 0? smoothMax(h, ph, lf): h :ph;
}

// FOR FRAGMENT
[numthreads(8, 8, 1)]
void NHMapGen(uint2 id : SV_DispatchThreadID)
{
    float2 step = (float2(id.x, id.y)) * 1.0 / 256.0;
    float3 samplePoint = normalize(_origin + ((_mx - _origin) * step.x) + ((_my - _origin) * step.y));
    float height = 0.0;

    //DONT TOUCH THIS ! correct lerping to squish the vec to color clamps.
    _NHMap[id.xy] = (half4(0, 0, 1, 1) + 1.0) * 0.5;
}



// PER VERTEX
[numthreads(8, 1, 1)]
void VertexRecompute(uint id : SV_DISPATCHTHREADID)
{
    if (id < _vNum)
    {
        // Position actuelle du vertex
        float3 vPos = normalize(_vertices[id]);

        const float Noffset = 0.002;
        
        float3 posXPlus = normalize(vPos + float3(Noffset, 0.0, 0.0));
        float3 posXMinus = normalize(vPos - float3(Noffset, 0.0, 0.0));
        float3 posYPlus = normalize(vPos + float3(0.0, Noffset, 0.0));
        float3 posYMinus = normalize(vPos - float3(0.0, Noffset, 0.0));
        float3 posZPlus = normalize(vPos + float3(0.0, 0.0, Noffset));
        float3 posZMinus = normalize(vPos - float3(0.0, 0.0, Noffset));

        float4 bChan = getBiomeChannels(vPos, _scale, 0.75, _offset);
        float4 bChanXP = getBiomeChannels(posXPlus, _scale, 0.75, _offset);
        float4 bChanXM = getBiomeChannels(posXMinus, _scale, 0.75, _offset);
        float4 bChanYP = getBiomeChannels(posYPlus, _scale, 0.75, _offset);
        float4 bChanYM = getBiomeChannels(posYMinus, _scale, 0.75, _offset);
        float4 bChanZP = getBiomeChannels(posZPlus, _scale, 0.75, _offset);
        float4 bChanZM = getBiomeChannels(posZMinus, _scale, 0.75, _offset);

        float res = 0.0;
        float resXP = 0.0;
        float resXM = 0.0;
        float resYP = 0.0;
        float resYM = 0.0;
        float resZP = 0.0;
        float resZM = 0.0;


        // get only the predicates matching => send them to sampleHeight as additional params => final position is the lerped sum of biome layers.
        for (int i = 0; i < _numBiomes; i++)
        {
            float4 mP = float4(_minPredicates[i][0], _minPredicates[i][1], _minPredicates[i][2], _minPredicates[i][3]);
            float4 MP = float4(_maxPredicates[i][0], _maxPredicates[i][1], _maxPredicates[i][2], _maxPredicates[i][3]);
            res = processBiomes(vPos, bChan, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], res);
            resXP = processBiomes(posXPlus, bChanXP, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], resXP);
            resXM = processBiomes(posXMinus, bChanXM, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], resXM);
            resYP = processBiomes(posYPlus, bChanYP, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], resYP);
            resYM = processBiomes(posYMinus, bChanYM, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], resYM);
            resZP = processBiomes(posZPlus, bChanZP, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], resZP);
            resZM = processBiomes(posZMinus, bChanZM, mP, MP, _genToUse[i], _paramsOfGen[i], _blendingFactor[i], resZM);
        }

        res+=bChan.x * _multiplier;
        resXP+=bChanXP.x * _multiplier;
        resXM+=bChanXM.x * _multiplier;
        resYP+=bChanYP.x * _multiplier;
        resYM+=bChanYM.x * _multiplier;
        resZP+=bChanZP.x * _multiplier;
        resZM+=bChanZM.x * _multiplier;

        // Position finale du vertex après déformation
        float3 vFinalPos = vPos * (1.0 + res) * _bRad;
        _vertices[id] = vFinalPos;


        // Calcul des positions déformées dans les trois directions
        posXPlus = posXPlus * (1.0 + resXP) * _bRad;

        posXMinus = posXMinus * (1.0 + resXM) * _bRad;

        posYPlus = posYPlus * (1.0 + resYP) * _bRad;

        posYMinus = posYMinus * (1.0 + resYM) * _bRad;

        posZPlus = posZPlus * (1.0 + resZP) * _bRad;

        posZMinus = posZMinus * (1.0 + resZM) * _bRad;

        // Calcul des gradients dans chaque direction
        float3 tangentX = posXPlus - posXMinus;
        float3 tangentY = posYPlus - posYMinus;
        float3 tangentZ = posZPlus - posZMinus;

        // X => YZ||ZY
        // Y => XZ||ZX
        // Z => XY||YX
        float3 normal;
        if (abs(vPos.x) >= abs(vPos.y) && abs(vPos.x) >= abs(vPos.z))
        {
            if (vPos.x >= 0.0) normal = cross(tangentY, tangentZ);
            else normal = cross(tangentZ, tangentY);
        }
        else if (abs(vPos.y) >= abs(vPos.x) && abs(vPos.y) >= abs(vPos.z))
        {
            if (vPos.y >= 0.0) normal = cross(tangentZ, tangentX);
            else normal = cross(tangentX, tangentZ);
        }
        else
        {
            if (vPos.z >= 0.0) normal = cross(tangentX, tangentY);
            else normal = cross(tangentY, tangentX);
        }

        // Normalisation finale
        _normals[id] = normalize(normal);
        _color[id] = bChan * .5 + 1.;
    }
}